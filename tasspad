#!/usr/bin/env python3
'''
Tasspad is a simple notepad/reminder app with a few flexible options
So you can turn your notes into nags, or executable commands, or tag them
Designed to sit in a system tray / notification area
'''
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Copyright (C) 2017 Brianna Rainey
#
# Tasspad is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program, in a file named "LICENSE".  If not, see
# <http://www.gnu.org/licenses/>
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# FIX: make quit button send signal to close all windows

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3, GObject
import signal
import datetime
import configparser
import os
import random
from textwrap import wrap
from subprocess import call
from string import ascii_letters


#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Globals
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
def makeConfigPath():
    ''' construct path to conf files for ConfigParser '''
    ConfigPath = os.path.join(os.getenv("HOME"), '.config', 'tasspad')
    if not os.path.exists(ConfigPath):
        if not os.path.exists(os.path.join(os.getenv("HOME"), '.config')):
            os.mkdir(os.path.join(os.getenv("HOME"), '.config'))
        os.mkdir(ConfigPath)
    return ConfigPath

def makeSrcPath():
    ''' construct path for resources (e.g., icons) '''
    filedir = os.path.dirname(os.path.realpath(__file__))
    filename = os.path.basename(os.path.realpath(__file__))
    SrcPath = os.path.join(filedir, '%s-src' % filename)
    if not os.path.exists(SrcPath):
        os.mkdir(SrcPath)
    return SrcPath

ConfigPath = makeConfigPath()
SrcPath = makeSrcPath()
Tray = None


#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Parsers
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
class _ConfigParser(configparser.ConfigParser):
    def __init__(self, path, defaults):
        super().__init__()
        self.path = path
        # make a new default file if none exists
        if not os.path.exists(path):

            _ = configparser.ConfigParser()
            for key, value in defaults.items():
                _[key] = value
            with open(path, 'w') as f:
                _.write(f)
            del _
        self.read(path)

    def save(self):
        with open(self.path, 'w') as f:
            self.write(f)
        if Tray:
            try:
                Tray.createMenu()
            except AttributeError as e:
                print("Error creating Tray Icon, but file saved OK\n%s" % e)


class ConfParser(_ConfigParser):
    def __init__(self, path=os.path.join(ConfigPath, 'conf.conf')):
        defaults =  {
            'general' : {
                        'app_name'   : 'Tasspad',
                        'icon'      : '%s/icon.svg' % SrcPath,
                        '_bool_use_system_icon' : 'true',
                        '_num_menu_width' : '29',
                        '_bool_add/cancel_swap' : 'false',
                        '_bool_apply/close_swap' : 'false',
                        '_bool_show_groups' : 'false',
                        '_bool_confirm_delete' : 'true',
                        '_bool_confirm_execute' : 'false',
                        '_bool_warn_when_editing' : 'true',
                        '_bool_click_submenus' : 'true',
                        },
            'soundboard' : {
                        'NewNote' : '[New Note]',
                        'NewGroup' : '[New Group]',
                        'Preferences' : 'Preferences',
                        'Quit' : 'Quit',
                        'Remove' : 'Remove',
                        'Edit' : 'Edit',
                        'ExecuteWarning' : \
'''The execute flag will cause this note to run the <b>body</b>
field as a shell command when the note is clicked. This can
easily cause problems if used incorrectly.''',
                        'WelcomeMessage' : \
'''Left click will delete notes by default, right-click will
bring up the edit window. From here the note can be
complicated with tweaks.''',
                        'IconWarning' : \
'''must be restarted for icon changes to take effect.''',
                    }
            }
        super().__init__(path, defaults)

        # if default keys are not in the file, fix it
        # it's probably something added in a later version
        for section, content in defaults.items():
            for key, value in content.items():
                if key in self[section]:
                    continue
                self[section][key] = value
                self.save()

class NotesParser(_ConfigParser):
    def __init__(self, path=os.path.join(ConfigPath, 'notes.conf')):
        if call("which zenity > /dev/null", shell=True) == 0:
            welcomeExecute = 'true'
            welcomeMessage = 'zenity --info --text="%s"' % Soundboard['WelcomeMessage']
        else:
            welcomeExecute = 'false'
            welcomeMessage = Soundboard['WelcomeMessage']
        defaults =  {
            'DEFAULT' : {
                        'title' : '',
                        'icon' : '',
                        'body' : '',
                        '_nomodify_time_created' : '',
                        '_nomodify_time_modified' : '',
                        'group' : '',
                        'tags' : '',
                        '_bool_execute' : 'false',
                        },
            'apricot' : {
                        'title' : 'Welcome!',
                        'body' : welcomeMessage,
                        '_bool_execute' : welcomeExecute,
                        '_nomodify_time_created' : currentTime(),
                        },
            }
        super().__init__(path, defaults)

    def uniqueName(self):
        while True:
            pname = "".join([random.choice(ascii_letters) for i in range(20)])
            if pname not in self.sections():
                self.add_section(pname)
                break
        return pname

    def new(self):
        window = NewNoteWindow()
        ch = window.run()
        if ch == Gtk.ResponseType.APPLY:
            newname = self.uniqueName()
            self[newname]['title'] = window.entry.get_text()
            self[newname]['_nomodify_time_created'] = currentTime()
            self.save()
        window.destroy()

    def edit(self, notename):
        window = EditWindow(self[notename])
        ch = window.run()
        if ch == Gtk.ResponseType.APPLY:
            for key in self[notename]:
                edited = False
                if key in window.fields:
                    entrytext = window.fields[key].get_text()
                    if entrytext != self[notename][key]:
                        edited = True
                        self[notename][key] = entrytext
                elif key in window.checkboxes:
                    state  = window.checkboxes[key].get_active()
                    if state != self.getboolean(notename, key):
                        edited = True
                    if state:
                        self[notename][key] = 'true'
                    else:
                        self[notename][key] = 'false'
                # gives any warnings as necessary
                if Config.getboolean('general', '_bool_warn_when_editing'):
                    if edited and key == '_bool_execute':
                        MessageWindow(Soundboard['ExecuteWarning'])
            self[notename]['_nomodify_time_modified'] = currentTime()
            self.save()
        window.destroy()

    def delete(self, notename):
        def do():
            self.remove_section(notename)
            self.save()
        confirmdelete = Config.getboolean('general', '_bool_confirm_delete')
        if confirmdelete:
            title = self[notename]['title']
            if len(self[notename]['title']) > 29:
                title = "%s..." % self[notename]['title'][:30]
            window = BooleanWindow('delete', '"%s"' % title)
            ch = window.run()
            if ch == Gtk.ResponseType.OK:
                do()
            window.destroy()
        else:
            do()


#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Dialogs
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
class _Dialog(Gtk.Dialog):
    def __init__(self):
        super().__init__(title=Config['general']['app_name'])
        if Config.getboolean('general', '_bool_use_system_icon'):
            self.set_icon_name('text-editor')
        else:
            self.set_icon_from_file(Config['general']['icon'])
        self.set_border_width(8)

class NewNoteWindow(_Dialog):
    def __init__(self):
        super().__init__()

        # construct content area
        self.entry = Gtk.Entry()
        self.entry.set_activates_default(True)
        self.bodyBox = self.get_content_area()
        self.bodyBox.pack_start(Gtk.Label("New note: "), False, False, 0)
        self.bodyBox.pack_start(self.entry, False, False, 0)
        # construct action area
        if Config.getboolean('general', '_bool_add/cancel_swap'):
            self.add_button(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)
            addButton = self.add_button(Gtk.STOCK_ADD, Gtk.ResponseType.APPLY)
        else:
            addButton = self.add_button(Gtk.STOCK_ADD, Gtk.ResponseType.APPLY)
            self.add_button(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)
        # make addButton default button
        addButton.set_can_default(True)
        self.set_default(addButton)
        self.show_all()

class EditWindow(_Dialog):
    def __init__(self, section):
        super().__init__()

        box = self.get_content_area()
        box.set_orientation(Gtk.Orientation.VERTICAL)
        self.fields = {}
        self.checkboxes = {}
        for key, value in section.items():
            field = Gtk.Box()
            displayKey = makeDisplayKey(key)
            field.add(Gtk.Label(displayKey))
            # change how value is edited based on prefix
            if key.startswith('_nomodify_'):
                field.pack_end(Gtk.Label(value), False, False, 0)
            elif key.startswith('_bool_'):
                check = Gtk.CheckButton()
                if value in ('true', 'yes'):
                    check.set_active(True)
                field.pack_end(check, False, False, 0)
                self.checkboxes[key] = check
            # elif key.startswith('_num_'):
                # insert entry with plus/minus buttons
            else:
                entry = Gtk.Entry()
                entry.set_text(value)
                field.pack_end(entry, False, False, 0)
                self.fields[key] = entry
            box.pack_start(field, False, False, 0)
        if Config.getboolean('general','_bool_apply/close_swap'):
            self.add_buttons(Gtk.STOCK_CLOSE, Gtk.ResponseType.CANCEL,
                             Gtk.STOCK_APPLY, Gtk.ResponseType.APPLY)
        else:
            self.add_buttons(Gtk.STOCK_APPLY, Gtk.ResponseType.APPLY,
                             Gtk.STOCK_CLOSE, Gtk.ResponseType.CANCEL)
        self.show_all()

class BooleanWindow(_Dialog):
    def __init__(self, action, thing):
        super().__init__()
        label = "Really %s %s?" % (action, thing)

        # construct content area
        self.bodyBox = self.get_content_area()
        self.bodyBox.pack_start(Gtk.Label(label), False, False, 0)
        # construct action area
        yesButton = self.add_button(Gtk.STOCK_YES, Gtk.ResponseType.OK)
        self.add_button(Gtk.STOCK_NO, Gtk.ResponseType.CANCEL)
        # make yesButton default button
        yesButton.set_can_default(True)
        #yesButton.set_activates_default(True)
        self.set_default(yesButton)
        self.show_all()

class MessageWindow(_Dialog):
    def __init__(self, text):
        super().__init__()
        self.bodyBox = self.get_content_area()
        label = Gtk.Label()
        label.set_markup(str(text))
        self.bodyBox.pack_start(label, False, False, 0)
        self.add_button(Gtk.STOCK_OK, Gtk.ResponseType.OK)
        self.show_all()
        self.run()
        self.destroy()

#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Greebles
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
class TrayIcon:
    def __init__(self):
        if Config.getboolean('general', '_bool_use_system_icon'):
            # Use the system icon instead of a custom path
            self.indicator = AppIndicator3.Indicator.new(
                Config['general']['app_name'], 'text-editor',
                AppIndicator3.IndicatorCategory.OTHER)
        else:
            self.indicator = AppIndicator3.Indicator.new(
                Config['general']['app_name'], Config['general']['icon'],
                AppIndicator3.IndicatorCategory.OTHER)
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
        self.createMenu()

    def createMenu(self):
        self.indicator.set_menu(self.buildMenu())

    def buildMenu(self):
        menu = Gtk.Menu()
        # NEW NOTE BUTTON
        newNoteItem = Gtk.ImageMenuItem(Soundboard['NewNote'])
        img = Gtk.Image()
        img.set_from_stock(Gtk.STOCK_NEW,1)
        newNoteItem.set_image(img)
        newNoteItem.connect('activate', lambda _: Notes.new())
        menu.append(newNoteItem)
        if Config.getboolean('general','_bool_show_groups'):
            newGroupItem = Gtk.ImageMenuItem(Soundboard['NewGroup'])
            img = Gtk.Image(); img.set_from_stock(Gtk.STOCK_INDEX, 1)
            newGroupItem.set_image(img)
            newGroupItem.connect('activate', lambda _: Notes.new())
            menu.append(newGroupItem)
        self.noteItems = []
        # LIST OF NOTES
        for noteName in Notes.sections():
            def leftClickAction(noteName):
                if Notes.getboolean(noteName, '_bool_execute'):
                    def do():
                        call('(%s &)' % Notes[noteName]['body'], shell=True)
                    confirmExecute = Config.getboolean('general', '_bool_confirm_execute')
                    if confirmExecute:
                        window = BooleanWindow('execute', '"%s"' % Notes[noteName]['body'])
                        ch = window.run()
                        if ch == Gtk.ResponseType.OK:
                            do()
                        window.destroy()
                    else:
                        do()
                else:
                    Notes.delete(noteName)

            def rightClickAction(noteName):
                Notes.edit(noteName)

            if noteName == 'DEFAULT':
                continue
            # make a primary menu item for this note...
            titlelines = wrap(Notes[noteName]['title'],
                              int(Config['general']['_num_menu_width']))
            if Notes[noteName]['icon']:
                item = Gtk.ImageMenuItem("\n".join(line for line in titlelines))
                image = Gtk.Image()
                image.set_from_file(Notes[noteName]['icon'])
                item.set_image(image)
            else:
                if Notes.getboolean(noteName, '_bool_execute'):
                    item = Gtk.ImageMenuItem("\n".join(line for line in titlelines))
                    img = Gtk.Image()
                    img.set_from_stock(Gtk.STOCK_EXECUTE,1)
                    item.set_image(img)
                else:
                    item = Gtk.MenuItem("\n".join(line for line in titlelines))
            self.noteItems.insert(0, item)

            if Notes[noteName]['body'] and not Notes.getboolean(noteName, '_bool_execute'):
                # make a submenu for the note's body...
                submenu = Gtk.Menu()
                removeButton = Gtk.MenuItem(Soundboard['Remove'])
                removeButton.connect(
                    'activate',
                    lambda _, section: leftClickAction(section),
                    noteName
                )
                editButton = Gtk.MenuItem(Soundboard['Edit'])
                editButton.connect(
                    'activate',
                    lambda _, section: Notes.edit(section),
                    noteName
                )

                lines = wrap(Notes[noteName]['body'],
                             int(Config['general']['_num_menu_width']))
                for line in lines:
                    submenu.append(Gtk.MenuItem(line))
                sep = Gtk.SeparatorMenuItem()
                submenu.append(sep)
                submenu.append(removeButton)
                submenu.append(editButton)
                self.noteItems[0].set_submenu(submenu)
                event = 'button-press-event'
            else:
                submenu = False
                event = 'button-release-event'
            if submenu and Config.getboolean('general', '_bool_click_submenus')\
                or not submenu:
                # bind left and right click to appropriate actions
                self.noteItems[0].connect(
                    event,
                    lambda _, k, section: \
                        leftClickAction(section) if k.button == 1 \
                        else rightClickAction(section),
                    noteName
                )
            if not submenu:
                self.noteItems[0].connect(
                    'activate',
                    lambda _, section: leftClickAction(section),
                    noteName
                )
            # add mainmenu item to mainmenu
            menu.append(self.noteItems[0])
        # END OF MENU
        menuSep = Gtk.SeparatorMenuItem()
        menu.append(menuSep)
        prefsItem = Gtk.ImageMenuItem(Soundboard['Preferences'])
        img = Gtk.Image(); img.set_from_stock(Gtk.STOCK_PREFERENCES,1)
        prefsItem.set_image(img)
        prefsItem.connect('activate', lambda _: self.editPrefs())
        menu.append(prefsItem)
        quitItem = Gtk.ImageMenuItem(Soundboard['Quit'])
        img = Gtk.Image(); img.set_from_stock(Gtk.STOCK_CLOSE,1)
        quitItem.set_image(img)
        quitItem.connect('activate', lambda _: self.stop())
        menu.append(quitItem)
        menu.show_all()
        return menu

    def editPrefs(self):
        window = EditWindow(Config['general'])
        ch = window.run()
        if ch == Gtk.ResponseType.APPLY:
            for key in Config['general']:
                edited = False
                if key in window.fields:
                    entrytext = window.fields[key].get_text()
                    if entrytext != Config['general'][key]:
                        edited = True
                        Config['general'][key] = entrytext
                elif key in window.checkboxes:
                    state  = window.checkboxes[key].get_active()
                    if state != Config.getboolean('general', key):
                        edited = True
                    if state:
                        Config['general'][key] = 'true'
                    else:
                        Config['general'][key] = 'false'
                # gives any warnings as necessary
                if Config.getboolean('general', '_bool_warn_when_editing'):
                    if edited and 'icon' in key:
                        MessageWindow("%s %s" % (\
                            Config['general']['app_name'],
                            Soundboard['IconWarning']
                            )
                        )
            Config.save()

        window.destroy()

    def stop(self):
        Gtk.main_quit()


#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Functions
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
def makeDisplayKey(key):
    # remove underscored prefix from keyname
    if key.startswith('_'):
        prefixlen = key[1:].index('_') + 2
        key = key[prefixlen:]
    try:
        # capitalize characters after remaining underscores
        keySegments = key.split('_')
        def capitalizedWords(words):
            for word in words:
                yield word.title()
        newkey = " ".join([word for word in capitalizedWords(keySegments)])
        return newkey
    except ValueError:
        # there's only one word so whatever
        return key.title()
    return key

def currentTime():
    current_time = datetime.datetime.now()
    return (
            "%s-%s-%s %s:%s" % (current_time.year,
                                current_time.month,
                                current_time.day,
                                current_time.hour,
                                current_time.minute)
            )

# Main
def main():
    # start GTK loop
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    Gtk.main()

if __name__ == "__main__":
    Config = ConfParser()
    Soundboard = Config['soundboard']
    Notes = NotesParser()
    try:
        Tray = TrayIcon()
    except AttributeError as e:
        print("Error creating Tray Icon\n%s" % e); quit(1)
    main()
