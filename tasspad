#!/usr/bin/env python3
'''
Tasspad is a simple notepad/reminder app with a few flexible options
So you can turn your notes into nags, or executable commands, or tag them
Designed to sit in a system tray / notification area
'''
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Copyright (C) 2017 Brianna Rainey
#
# Tasspad is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program, in a file named "COPYING".  If not, see
# <http://www.gnu.org/licenses/>
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3, GObject
import signal
import datetime
import configparser
import os
import random
from textwrap import wrap
from subprocess import call
from string import ascii_letters

#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Globals
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
def makeConfigPath():
    ''' construct path to conf files for ConfigParser '''
    ConfigPath = os.path.join(os.getenv("HOME"), '.config', 'tasspad')
    if not os.path.exists(ConfigPath):
        if not os.path.exists(os.path.join(os.getenv("HOME"), '.config')):
            os.mkdir(os.path.join(os.getenv("HOME"), '.config'))
        os.mkdir(ConfigPath)
    return ConfigPath

def makeSrcPath():
    ''' construct path for resources (e.g., icons) '''
    filedir = os.path.dirname(os.path.realpath(__file__))
    filename = os.path.basename(os.path.realpath(__file__))
    SrcPath = os.path.join(filedir, '%s-src' % filename)
    if not os.path.exists(SrcPath):
        os.mkdir(SrcPath)
    return SrcPath

ConfigPath = makeConfigPath()
SrcPath = makeSrcPath()
Tray = None


#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Parsers
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
class _ConfigParser(configparser.ConfigParser):
    def __init__(self, path, defaults):
        super().__init__()
        self.path = path
        # make a new default file if none exists
        if not os.path.exists(path):

            _ = configparser.ConfigParser()
            for key, value in defaults.items():
                _[key] = value
            with open(path, 'w') as f:
                _.write(f)
            del _
        self.read(path)

    def save(self):
        with open(self.path, 'w') as f:
            self.write(f)
        if Tray:
            Tray.createMenu()


class ConfParser(_ConfigParser):
    def __init__(self, path=os.path.join(ConfigPath, 'conf.conf')):
        defaults =  {
            'general' : {
                        'appname'   : 'Tasspad',
                        'icon'      : '%s/icon.svg' % SrcPath,
                        '_bool_usesystemicon' : 'true',
                        'theme'     : 'default',
                        'menuwidth' : '29',
                        '_bool_usegroups' : 'false',
                        '_bool_confirmdelete' : 'true',
                        },
            }
        super().__init__(path, defaults)

        # if default keys are not in the file, fix it
        # it's probably something added in a later version
        for section, content in defaults.items():
            for key, value in content.items():
                if key in self[section]:
                    continue
                self[section][key] = value
                self.save()

class NotesParser(_ConfigParser):
    def __init__(self, path=os.path.join(ConfigPath, 'notes.conf')):
        defaults =  {
            'DEFAULT' : {
                        'title' : '',
                        'body' : '',
                        '_nomodify_timecreated' : '',
                        '_nomodify_timemodified' : '',
                        'group' : 'main',
                        'tags' : '',
                        '_bool_execute' : 'false',
                        },
            'apricot' : {
                        'title' : 'Welcome!',
                        '_nomodify_timecreated' : currentTime(),
                        },
            }
        super().__init__(path, defaults)

    def uniqueName(self):
        while True:
            pname = "".join([random.choice(ascii_letters) for i in range(20)])
            if pname not in self.sections():
                self.add_section(pname)
                break
        return pname

    def new(self):
        window = NewNoteWindow()
        ch = window.run()
        if ch == Gtk.ResponseType.APPLY:
            newname = self.uniqueName()
            self[newname]['title'] = window.entry.get_text()
            self[newname]['_nomodify_timecreated'] = currentTime()
            self.save()
        window.destroy()

    def edit(self, notename):
        window = EditWindow(self[notename])
        while True:
            ch = window.run()
            if ch == Gtk.ResponseType.APPLY:
                for key, value in self[notename].items():
                    if key.startswith('time'):
                        continue
                    entrytext = window.fields[key].get_text()
                    if entrytext != self[notename][key]:
                        self[notename][key] = entrytext
                self[notename]['_nomodify_timemodified'] = currentTime()
                self.save()
                break
            elif ch == Gtk.ResponseType.CANCEL:
                break
        window.destroy()

    def delete(self, notename):
        def do():
            self.remove_section(notename)
            self.save()
        confirmdelete = Config.getboolean('general', '_bool_confirmdelete')
        if confirmdelete:
            title = self[notename]['title']
            if len(self[notename]['title']) > 29:
                title = "%s..." % self[notename]['title'][:30]
            window = BooleanWindow('delete', '"%s"' % title)
            ch = window.run()
            if ch == Gtk.ResponseType.OK:
                do()
            window.destroy()
        else:
            do()


#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Dialogs
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
class _Dialog(Gtk.Dialog):
    def __init__(self):
        super().__init__(title=Config['general']['appname'])
        if Config.getboolean('general', '_bool_usesystemicon'):
            self.set_icon_name('text-editor')
        else:
            self.set_icon_from_file(Config['general']['icon'])
        self.set_border_width(8)

class NewNoteWindow(_Dialog):
    def __init__(self):
        super().__init__()

        # construct content area
        self.entry = Gtk.Entry()
        self.entry.set_activates_default(True)
        self.bodyBox = self.get_content_area()
        self.bodyBox.pack_start(Gtk.Label("New note: "), False, False, 0)
        self.bodyBox.pack_start(self.entry, False, False, 0)
        # construct action area
        addButton = self.add_button(Gtk.STOCK_ADD, Gtk.ResponseType.APPLY)
        self.add_button(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)
        # make addButton default button
        addButton.set_can_default(True)
        self.set_default(addButton)
        self.show_all()

class EditWindow(_Dialog):
    def __init__(self, section):
        super().__init__()

        box = self.get_content_area()
        box.set_orientation(Gtk.Orientation.VERTICAL)
        self.fields = {}
        self.checkboxes = {}
        for key, value in section.items():
            field = Gtk.Box()
            if key.startswith('_'):
                # remove underscored prefix from keyname
                prefixlen = key[1:].index('_') + 2
                newkey = key[prefixlen:]
                field.add(Gtk.Label(newkey))
                # change how value is edited based on prefix
                if key.startswith('_nomodify_'):
                    field.pack_end(Gtk.Label(value), False, False, 0)
                elif key.startswith('_bool_'):
                    check = Gtk.CheckButton()
                    if value in ('true', 'yes'):
                        check.set_active(True)
                    field.pack_end(check, False, False, 0)
                    self.checkboxes[key] = check
                else:
                    print('Illegal keyname in ', section); quit(1)
            else:
                field.add(Gtk.Label(key))
                entry = Gtk.Entry()
                entry.set_text(value)
                field.pack_end(entry, False, False, 0)
                self.fields[key] = entry
            box.pack_start(field, False, False, 0)
        self.add_buttons(Gtk.STOCK_APPLY, Gtk.ResponseType.APPLY,
                         Gtk.STOCK_CLOSE, Gtk.ResponseType.CANCEL)
        self.show_all()

class PrefsWindow(_Dialog):
    def __init__(self):
        super().__init__()

class BooleanWindow(_Dialog):
    def __init__(self, action, thing):
        super().__init__()
        label = "Really %s %s?" % (action, thing)

        # construct content area
        self.bodyBox = self.get_content_area()
        self.bodyBox.pack_start(Gtk.Label(label), False, False, 0)
        # construct action area
        yesButton = self.add_button(Gtk.STOCK_YES, Gtk.ResponseType.OK)
        self.add_button(Gtk.STOCK_NO, Gtk.ResponseType.CANCEL)
        # make yesButton default button
        yesButton.set_can_default(True)
        #yesButton.set_activates_default(True)
        self.set_default(yesButton)
        self.show_all()

class MessageWindow(_Dialog):
    def __init__(self, text):
        super().__init__()
        self.bodyBox = self.get_content_area()
        self.bodyBox.pack_start(Gtk.Label(str(text)), False, False, 0)
        self.add_button(Gtk.STOCK_OK, Gtk.ResponseType.OK)
        self.show_all()
        self.run()
        self.destroy()

#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Greebles
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
class TrayIcon:
    def __init__(self):
        if Config.getboolean('general', '_bool_usesystemicon'):
            # Use the system icon instead of a custom path
            self.indicator = AppIndicator3.Indicator.new(
                Config['general']['appname'], 'text-editor',
                AppIndicator3.IndicatorCategory.OTHER)
        else:
            self.indicator = AppIndicator3.Indicator.new(
                Config['general']['appname'], Config['general']['icon'],
                AppIndicator3.IndicatorCategory.OTHER)
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
        self.createMenu()

    def createMenu(self):
        self.indicator.set_menu(self.buildMenu())

    def buildMenu(self):
        menu = Gtk.Menu()
        newNoteItem = Gtk.MenuItem('[New Note]')
        newNoteItem.connect('activate', lambda _: Notes.new())
        menu.append(newNoteItem)
        if Config.getboolean('general','_bool_usegroups'):
            newGroupItem = Gtk.MenuItem('[New Group]')
            newGroupItem.connect('activate', lambda _: Notes.new())
            menu.append(newGroupItem)
        self.noteItems = []
        # notes
        for noteName in Notes.sections():
            def leftClickAction(noteName):
                if Notes.getboolean(noteName, '_bool_execute'):
                    call('(%s &)' % Notes[noteName]['title'], shell=True)
                else:
                    Notes.delete(noteName)
            if noteName == 'DEFAULT':
                continue
            # make a primary menu item for this note...
            titlelines = wrap(Notes[noteName]['title'],
                              int(Config['general']['menuwidth']))
            item = Gtk.MenuItem("\n".join(line for line in titlelines))
            self.noteItems.insert(0, item)

            if Notes[noteName]['body']:
                # make a submenu for the note's body...
                submenu = Gtk.Menu()
                removeButton = Gtk.MenuItem('Remove')
                editButton = Gtk.MenuItem('Edit')
                removeButton.connect(
                    'activate',
                    lambda _, section: leftClickAction(section),
                    noteName
                )
                editButton.connect(
                    'activate',
                    lambda _, section: Notes.edit(section),
                    noteName
                )

                lines = wrap(Notes[noteName]['body'],
                             int(Config['general']['menuwidth']))
                for line in lines:
                    submenu.append(Gtk.MenuItem(line))
                sep = Gtk.SeparatorMenuItem()
                submenu.append(sep)
                submenu.append(removeButton)
                submenu.append(editButton)
                self.noteItems[0].set_submenu(submenu)
            else:
                # hide submenu, bind left and right click to edit and delete
                self.noteItems[0].connect(
                    'button-press-event',
                    lambda _, k, section: \
                        leftClickAction(section) if k.button == 1 \
                        else Notes.edit(section),
                    noteName
                )
            # add mainmenu item to mainmenu
            menu.append(self.noteItems[0])
        # end of menu
        menuSep = Gtk.SeparatorMenuItem()
        menu.append(menuSep)
        prefsItem = Gtk.MenuItem('Preferences')
        prefsItem.connect('activate', lambda _: self.editPrefs())
        menu.append(prefsItem)
        quitItem = Gtk.MenuItem('Quit')
        quitItem.connect('activate', lambda _: self.stop())
        menu.append(quitItem)
        menu.show_all()
        return menu

    def editPrefs(self):
        window = EditWindow(Config['general'])
        ch = window.run()
        if ch == Gtk.ResponseType.APPLY:
            for key in Config['general']:
                edited = False
                if key in window.fields:
                    entrytext = window.fields[key].get_text()
                    if entrytext != Config['general'][key]:
                        edited = True
                        Config['general'][key] = entrytext
                elif key in window.checkboxes:
                    state  = window.checkboxes[key].get_active()
                    if state != Config.getboolean('general', key):
                        edited = True
                    if state:
                        Config['general'][key] = 'true'
                    else:
                        Config['general'][key] = 'false'
                if edited and 'icon' in key:
                    MessageWindow("%s must be restarted for icon changes to take effect" %\
                        Config['general']['appname'])
            Config.save()

        window.destroy()

    def stop(self):
        Gtk.main_quit()


#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
# Functions
#
#=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~==~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~#
def currentTime():
    current_time = datetime.datetime.now()
    return (
            "%s-%s-%s %s:%s" % (current_time.year,
                                current_time.month,
                                current_time.day,
                                current_time.hour,
                                current_time.minute)
            )

# Main
def main():
    # start GTK loop
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    Gtk.main()

if __name__ == "__main__":
    Config = ConfParser()
    Notes = NotesParser()
    Tray = TrayIcon()
    main()
